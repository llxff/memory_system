\documentclass[russian,utf8,simple,hpadding=10mm,vpadding=20mm]{eskdtext}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{mathtext}
\usepackage[numberright]{eskdplain}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{color}
\usepackage{setspace}
\ESKDdepartment{МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ РФ}
\ESKDcompany{Университет управления «ТИСБИ»}
\renewcommand{\ESKDtitleFontIII}{\normalsize}
\renewcommand{\ESKDtheTitleFieldIII}{Специальность 09.03.01 «Информатика и вычислительная техника»}
\renewcommand{\ESKDtitleFontIV}{\LARGE}
\renewcommand{\ESKDtheTitleFieldIV}{КУРСОВАЯ РАБОТА}
\renewcommand{\ESKDtitleFontV}{\Large}
\renewcommand{\ESKDtheTitleFieldV}{НА ТЕМУ: «Разработка объектной программы для задачи моделирования подсистемы управления основной памятью»}
\renewcommand{\ESKDtheTitleFieldX}{Казань,~2017г.}
\renewcommand{\ESKDtheTitleFieldVIII}{
\null\hfill
\begin{minipage}{0.5\textwidth}
\normalsize ВЫПОЛНИЛ студент гр. ДЗИ 105Н:
\\Фомин~А.~В.
\\ПРОВЕРИЛ преподаватель:
\\Козин~А.~Н.
\end{minipage}\\}
\ESKDdate{2017/07/21}
\renewcommand{\thefootnote}{\arabic{footnote}}
\begin{document}
\maketitle
\newpage

\sloppy

\linespread{1,5}
\tableofcontents

\newpage
\parindent=12.5mm
\linespread{2}
\section{Постановка задачи}

Разработать объектную программу для хранения и обработки данных о процессах и используемых ими страницах основной памяти в многозадачных ОС. Каждый процесс имеет уникальный идентификатор и рассматривается как набор страниц. В свою очередь каждая страница имеет уникальный номер и параметр «Состояние».

Разработка включает в себя определение необходимых объектов и описание их в виде классов, программную реализацию методов добавления и удаления процессов и страниц, всестороннее тестирование методов с помощью консольного (при разработке) и оконного (в окончательном варианте) приложения.

Для объединения процессов используется структура данных в виде адресного разомкнутого упорядоченного однонаправленного списка без заголовка. Для объединения страниц внутри процессов  используется очередь на основе обычного массива со сдвигом элементов.


\newpage
\parindent=15mm
\doublespacing
\section{Описание используемых структур данных с алгоритмами выполнения основных операций}

При реализации задачи мною был реализован класс списка процессов при помощи упорядоченного однонаправленного связанного списка и класс очереди страниц памяти на основе обычного массива со сдвигом элементов.

Класс списка процессов ProcessesList содержит в себе внутренний класс ListItem, который является списковым контейнером и содержит в себе объект класса Process, ссылку на следующий объект контейнера в списке. Помимо базовых геттеров и сеттеров для установки и чтения объектов класса Process и следущего элемента, класс ListItem содержит метод isSmallerThan, необходимый для сравнения с другим объектом класса ListItem. Результатом выполнения этого метода является boolean значение. Если оно принимает значение true, то это означает что текущий объект класса ListItem меньше переданного объекта класса ListItem. Если значение false, то это означает что текущий объект класса ListItem больше переданного объекта класса ListItem. Этот метод необходим для реализации упорядоченного списка процессов, когда первый элемент списка является наименьшим объектом класса Process, а следующие элементы расположены в порядке возрастания.

Основной класс ProcessesList содержит в себе ссылку на корневой объект контейнера класса Process с типом ListItem и поле типа int со значением количества элементов в списке процессов. 

Помимо методов получения корневого элемента и количества элементов, класс ProcessesList реализует методы добавления процесса в список, удаление элемента из списка по индексу, получение индекса в списке конкретного объекта класса Process и получение объекта класса Process из списка по индексу. Рассмотрим алгоритмы реализации этих методов подробнее.

При добавлении объекта в список сначала происходит проверка, что список не пустой. Если список пустой, то переданный объект становится корневым элементом списка и значение количества элементов в списке становится равным единице. Если список не пустой, то происходит проверка на то, что переданный объект меньше корневого элемента. Если переданный объект меньше, то он становится корневым элементом и значение количества элементов в списке увеличивается на единицу. Если переданный объект больше корневого элемента, то он сравнивается со следующим элементом после корневого. Если переданный объект меньше, то у предыдущего элемента ссылка на следующий элемент изменяется на контейнер с переданным объектом, а у контейнера переданного объекта ссылка на следующий устанавлиявается на ссылку предыдущего контейнера. Если же переданный объект больше следующего элемента в списке, то эта операция сравнения происходит со следующим элементом. В итоге сложностью добавления нового элемента в упорядоченный список в худшем случае является O(n), где n - это количество элементов в списке.

При удалении элемента из списка по индексу сначала проверяется, не равен ли переданный индекс 0. Если это так, то корневым элементом списка становится следующее значение текщего корневого элемента и значение количества элементов в списке уменьшается на единицу. Если передано значение больше 0, то происходит поиск элемента с нужным индексом в цикле, после чего у его предыдушего значение ссылка на следующий элемент устанавливается в значение следующего элемента найденного объекта и значение количества элементов в списке уменьшается на единицу. Таким образом сложность удаления элемента из упорядоченного списка является O(n), где n - это значение индекса.

При получении элемента по индексу так же происходит перебор элементов в списке n раз и сложность получения элемента из списка по индексу является O(n), где n - это значение индекса.

При получении позиции объкта класса Process в списке  так же происходит перебор элементов в списке, пока не будет найдено соответсвие между переданным объектом и объектом в контейнере. Таким образом в худшем случае сложность получения индекса является O(n), где n - это количество элемнтов в списке.

Класс очереди страниц памяти MemoryPagesQueue содержит в себе массив объектов класса MemoryPage, число элементов в очереди, и значение максимальный размер очереди. Класс реализует методы добавления объекта класса MemoryPage в очередь, извлечение объекта класса MemoryPage из очереди, проверки на пустоту очереди, проверки на заполненность очереди, количества элементов в очереди и получение массива объектов класса MemoryPage.

Метод добавлени нового элемента в очередь релизован следующим образом. Если очередь не заполнена полностью, то в массив объектов памяти добавляется переданный объект памяти с индексом, равным значению количества элементов в массиве плюс единица. Если очередь заполнена, то генерируется исключение типа IllegalStateException. Таким образом сложность добавления элемента в очередь равна O(1).

При извлечении элемента из очереди в переменную сохраняется первый элемент в списке, и после этого следующие элементы в массиве последовательно сдвигаются влево, либо заполняются пустыми значениями. Таким образом сложность извлечения элемента из очереди равна O(n), где n - это максимальный размер очереди.

\newpage
\parindent=15mm
\doublespacing
\section{Краткие сведения об объектном подходе}
Развитие объектно-ориентированное программирование началось в 1960-ых годах с языка Симула, однако основные обороты начало набирать только во второй половине 1990-ых годов. 

Основополагающей идеей объектно-ориентированного подхода является объединение данных и действий, производимых над этими данными, в единое целое, которое называется объектом. Данные, содержащиеся в объекте, представляют его состояние. В терминологии объектно-ориентированного программирования эти данные называются атрибутами. Действия объекта представляют собой то, что может сделать объект. В процедурных языках поведение определяется процедурами, функциями и подпрограммами. В терминологии объектно-ориентированного программирования поведения объектов содержатся в методах.

Создание экземпляра объекта происходит на основе класса, который определяет одновременно как интерфейс, так и реализацию поведения. Данные в классе представляются атрибутами, которые хранят состояние каждого объекта. Доступ к атрибутам может быть публичным, когда любой может получить доступ к этим атрибутам, может быть защищенным, когда доступ к данным могут получить только связанные объекты, либо приватным, когда атрибуты доступны только самому объекту.

Поведение в классе описывается при помощи методов. Они могут реализовывать поведение, вызываемые из других объектов либо обеспечивать основное, внутреннее поведение класса. Внутреннее поведение описывается с помощью закрытых методов, которые недоступны другим объектам.  Эта методика широко распространенна в сфере объектно-ориентированных систем. Во всех случаях доступ к атрибутам в объекте должен контролироваться самим этим объектом - никакие другие объекты не должны напрямую изменять значения атрибутов этого объекта.

Ограничение доступа к атрибутам и методам имеют под собой вескую причину: стремление избежать зависимости от них у других объектов, чтобы была возможность свободно изменять реализацию и типы этих атрибутов и методов.  Однако это ограничение не связано с простой прослойкой  между приватными данными  помощью так называемых геттеров и сеттеров, оно связано с формированием абстракций. Таким образом класс не просто ограничивает доступ к чтению и записи атрибутов,  а предоставляет  абстрактный интерфейс с помощью которого происходит оперирование с самой сущностью данных, причем при этом нет никакой необходимости знать, как устроены эти данные. Таким образом объекты скрывают свои данные за абстракциями и предоставляют методы, работающие с этими данными. Наряду с абстракцией, основными концепциями объектно-ориентированного программирования являются инкапсуляция, наследование и полиморфизм. Рассмотрим эти концепции подробнее.

Инкапсуляция определяется тем, что объекты содержат как атрибуты, так и по-
ведения. Скрытие данных является основной частью инкапсуляции. Таким образом
данные невидимы и недоступны извне.  Инкапсуляция неразрывно связана с понятием интерфейса класса. По сути, все то, что не входит в интерфейс, инкапсулируется в классе.

С помощью наследования можно определять отношения между классами, которые не только облегчают повторное использование кода, но и способствуют созданию лучшей общей конструкции путем упорядочения и учета общности разнообразных классов.
Если подкласс наследует родительский класс, то он включает определения всех
аттрибутов и методов, определенных в родительском классе. Объекты, являющиеся экземплярами подкласса, будут содержать все данные, определенные как в самом подклассе, так и во всех его родительских классах. Такой объект сможет выполнять все действия, определенные в подклассе и его предках. Таким образом благодаря наследованию есть возможность организовывать большие иерархии программных конструкций с идентичными интерфейсами. Все
подклассы могут отвечать на запросы, соответствующие интерфейсу родительского класса. Наибольшая мощь наследования проявляется при использовании абстрактных классов, потому что в этом случае клиенту не нужно знать о конкретных типах объектов, которыми он пользуется,  и о классах, с помощью которых реализованы объекты. Достаточно лишь об абстрактном классе, определяющих интерфейс. Благодоря этому существенно уменьшается число зависимостей между подсистемами. Альтернативой наследованию может служить композиция объектов. В этом случае новая функциональность получается с помощью объединения объектов. Композицию можно применить, если объекты соблюдают интерфейсы друг друга. Для этого требуется тщательно проектировать интерфейсы, так чтобы один объект можно было использовать вместе с другими. Таким образом инкапсулируется каждый класс и он выполняет только свою задачу, при этом иерархия классов остается небольшой.

Полиморфизм упрощает определение клиентов, позволяет отделить объекты друг от друга и дает объектам возможность изменять взаимоотношения во время выполнения. Он дает возможность подставлять во время выполнения вместо одного объекта другой с совместимым интерфейсом, таким образом мы можем работать с группами связанных объектов универсальным способом.

\newpage
\parindent=15mm
\linespread{1,5}
\section{Формализованное описание разработанных классов}

\newpage
\parindent=15mm
\linespread{1,5}
\section{Описание демонстрационного модуля}

\begin{figure}[!hb]
    \centering
    \includegraphics[width=1\textwidth]{screenshots/1.png}
    \caption{Начальный экран}
    \label{fig:mesh1}
\end{figure}
\begin{figure}[!h]
    \centering
    \includegraphics[width=1\textwidth]{screenshots/2.png}
    \caption{Меню добавление процесса}
    \label{fig:mesh2}
\end{figure}
\begin{figure}[!h]
    \centering
    \includegraphics[width=1\textwidth]{screenshots/3.png}
    \caption{Меню управления памятью процесса}
    \label{fig:mesh3}
\end{figure}
\begin{figure}[!h]
    \centering
    \includegraphics[width=1\textwidth]{screenshots/4.png}
    \caption{Просмотр памяти процесса}
    \label{fig:mesh4}
\end{figure}
\begin{figure}[!h]
    \centering
    \includegraphics[width=1\textwidth]{screenshots/5.png}
    \caption{Изменение статуса памяти}
    \label{fig:mesh5}
\end{figure}

Графичиский интерфейс приложения реализован при помощи технологии JavaFX и описан в файле project.fxml.
 
При запуске приложения открывается окно, которое показано на рисунке 1. Окно содержит следующие элементы: список процессов, таблица объектов памяти выбранного процесса, кнопка сохранить и кнопка загрузить. 

Список процессов реализован при помощи компонента TreeView. При инициализации приложения происходит первоначальная настройка компонента списка процессов. Первым делом устанавливается корневой элемент с надписью "Список процесов", добавляется обработчик для события клика по элементу списка процессов, который отобразит очередь объектов памяти выбранного процесса, а так же задает фабрику обработчика элементов списка процессов. Этот обработчик управляет отображением контекстного меню процесса и управляет обработкой действий для выбранного элемента конекстного меню.

Таблица объектов памяти рализована при помощи компонента TableView. При инициализации приложения происходит настройка таблицы объектов памяти. Устанавливаются маппинг номера объекта памяти соответствующей колонке в таблице объектов памяти и настройка отображения статуса объекта памяти. Отображение статуса происходит при помощи класса MemoryStatus, который определяет маппинг внутреннего значения статуса объекта памяти человеческому значению, а так же определяет, какие значения статусов возможны для установки.

Кнопки сохранения и загрузки списка процессов реализованы при помощи компонентов Button.

Обработчиком события клика по компоненту кнопки сохранения списка процессов является метод saveProcessesList контроллера MaiinController. При вызове этого метода происходит отображение диалога сохранения файла и после задания нужных параметров происходит инициализация объекта класса VirtualMachine, с помощью которого происходит сериализация списка процессов в XML файл.

Обработчиком события клика по компоненту кнопки загрузки списка процессов является метод loadProcessesList контроллера MaiinController. При вызове этого метода происходит отображение диалога выбра файла и после задания нужных параметров происходит инициализация объекта класса VirtualMachine, с помощью которого происходит десериализация списка процессов из выбранного XML файла с последующим отображением загруженного списка процессов в интерфейсе программы.
 
Для добавления процесса необходимо нажать правой кнопкой мыши на элемент "Список процессов" в области списка процессов. После этого отобразится контекстное меню, которое изображено на рисунке 2. Это контекстное меню содержит 1 меню "Добавить процесс", при выборе которого добавится новый процесс в объект класса ProcessList, значение которого отображено в списке процессов. 

Для добавления новой страницы памяти, удаления процесса или памяти, необходимо выбрать нужный процесс в списке процессов и нажать на него правой кнопкой мыши. После этого отобразиться контекстное меню процесса, которое содержит следующие пункты меню. Это контекстное меню изображено на рисунке 3.

Добавить страницу памяти - при выборе этого элемента меню, будет добавлен новый объект памяти MemoryPage в выбранный процесс.

Удалить процесс - при выборе этого элемента меню, будет удален выбранный процесс из списка процессов и список процессов будет перерисован.

Удалить память - при выборе этого элемента меню, будет объект памяти будет извлечен из очереди памяти процесса.

На рисунке 4 изображено окно программы после добавления процессов или загрузки ранее сохраненных процессов.

Для изменения статуса памяти нужно выбрать необходимый процесс, после чего в таблице объектов памяти процесса нужно дважды кликнуть по статусу нужной памяти. После этого в открывшемся списке возможных статусов, который изображен на рисунке 5, выбрать необходимый статус.

\newpage
\parindent=15mm
\linespread{1,5}
\section{Описание структуры проекта в соответствии с использованным инструментом разработки}

\newpage
\begin{thebibliography}{99}
\bibitem{01}	Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес «Приемы объектно-ориентированного проектирования. Паттерны проектирования». Санкт-Петербург «Питер» 2016 г.
\bibitem{01}	Роберт К. Мартин «Чистый код: создание, анализ и рефакторинг». Санкт-Петербург «Питер» 2016 г.
\bibitem{01}	Стив Макконнелл «Совершенный код». Санкт-Петербург «BHV» 2017 г.
\bibitem{01}	Мартин Фаулер, Дейвид Райс, Мэттью Фоммел, Эдвард Хайет, Роберт Ми, Рэнди Стаффорд «Шаблоны корпоративных приложений». Москва «Вильямс» 2016 г.
\bibitem{01}	Томас Х. Кормен, Чарльз И. Лейзерсон, Рональд Л. Ривест, Клиффорд Штайн «Алгоритмы. Построение и анализ». Москва «Вильямс» 2016 г.
\bibitem{01}	Харольд Абельсон, Джеральд Джей Сассман «Структура и Интерпретация Компьютерных Программ». Москва «Добросвет» 2010 г.
\bibitem{01}	Эрик Эванс «Предметно-ориентированное проектирование (DDD). Структуризация сложных программных систем». Москва «Вильямс» 2017 г.
\bibitem{01}	Sandi Metz, Katrina Owen «99 Bottles of OOP». 2017 г.
\bibitem{01}	Robert Liguori, Patricia Liguori «Java Pocket Guide». Newton «O'Reilly Media» 2008 г.
\end{thebibliography}

\newpage
\parindent=12.5mm
\linespread{1,5}
\section*{Полный листинг программы с краткими комментариями}
\addcontentsline{toc}{section}{Полный листинг программы с краткими комментариями}%

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{light-gray}{gray}{0.25}

\lstdefinestyle{java}{
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\footnotesize\ttfamily},
  numberstyle={\tiny},
  numbers=left,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\lstdefinestyle{xml}{
  language=XML,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\footnotesize\ttfamily},
  numberstyle={\tiny},
  numbers=left,
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  morekeywords={AnchorPane, children, TreeView, TableView, placeholder, Label, columns, TableColumn, font, Font, Button, import}
}

\lstinputlisting[caption=Main, style=java,  inputencoding=cp1251]{src/main/java/com/github/llxff/Main.java}

\lstinputlisting[caption=MainController, style=java,  inputencoding=cp1251]{src/main/java/com/github/llxff/MainController.java}

\lstinputlisting[caption=MemoryStatus, style=java,  inputencoding=cp1251]{src/main/java/com/github/llxff/MemoryStatus.java}

\lstinputlisting[caption=ProcessTreeCell, style=java,  inputencoding=cp1251]{src/main/java/com/github/llxff/ProcessTreeCell.java}

\lstinputlisting[caption=MemoryPage, style=java,  inputencoding=cp1251]{src/main/java/com/github/llxff/domain/MemoryPage.java}

\lstinputlisting[caption=MemoryPagesQueue, style=java,  inputencoding=cp1251]{src/main/java/com/github/llxff/domain/MemoryPagesQueue.java}

\lstinputlisting[caption=Process, style=java,  inputencoding=cp1251]{src/main/java/com/github/llxff/domain/Process.java}

\lstinputlisting[caption=ProcessesList, style=java,  inputencoding=cp1251]{src/main/java/com/github/llxff/domain/ProcessesList.java}

\lstinputlisting[caption=VirtualMachine, style=java,  inputencoding=cp1251]{src/main/java/com/github/llxff/domain/VirtualMachine.java}

\lstinputlisting[caption=project.fxml, inputencoding=utf8, style=xml]{src/main/resources/fxml/project.fxml}

\end{document}
